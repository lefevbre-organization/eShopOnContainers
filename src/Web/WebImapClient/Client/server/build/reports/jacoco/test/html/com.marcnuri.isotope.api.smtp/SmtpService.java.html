<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SmtpService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">api</a> &gt; <a href="index.source.html" class="el_package">com.marcnuri.isotope.api.smtp</a> &gt; <span class="el_source">SmtpService.java</span></div><h1>SmtpService.java</h1><pre class="source lang-java linenums">/*
 * SmtpService.java
 *
 * Created on 2018-10-07, 18:25
 *
 * Copyright 2018 Marc Nuri
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.marcnuri.isotope.api.smtp;

import com.marcnuri.isotope.api.credentials.Credentials;
import com.marcnuri.isotope.api.exception.AuthenticationException;
import com.marcnuri.isotope.api.exception.IsotopeException;
import com.marcnuri.isotope.api.http.IsotopeURLDataSource;
import com.marcnuri.isotope.api.message.Attachment;
import com.marcnuri.isotope.api.message.Message;
import com.marcnuri.isotope.api.message.MessageUtils;
import com.sun.mail.util.MailSSLSocketFactory;
import com.sun.mail.imap.IMAPFolder;
import com.sun.mail.imap.IMAPStore;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.web.context.annotation.RequestScope;

import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.annotation.PreDestroy;
import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.Folder;
import javax.mail.Address;
import javax.mail.Flags;
import javax.mail.event.TransportEvent;
import javax.mail.event.TransportListener;
import javax.mail.internet.InternetHeaders;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import javax.mail.internet.MimeUtility;
import javax.mail.util.ByteArrayDataSource;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.List;
import java.util.Date;
import java.util.Properties;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.marcnuri.isotope.api.configuration.IsotopeApiConfiguration.DEFAULT_CONNECTION_TIMEOUT;
import static com.marcnuri.isotope.api.exception.AuthenticationException.Type.SMTP;
import static com.marcnuri.isotope.api.folder.FolderResource.REL_DOWNLOAD;
import static com.marcnuri.isotope.api.message.Message.HEADER_IN_REPLY_TO;
import static com.marcnuri.isotope.api.message.Message.HEADER_REFERENCES;


//import com.sun.mail.imap.protocol.RFC822DATA;
import com.sun.mail.imap.protocol.IMAPProtocol;
//import com.sun.mail.imap.IMAPFolder.ProtocolCommand;
//import com.sun.mail.imap.protocol.FetchResponse;
//import java.net.ProtocolException;
import com.sun.mail.iap.Response;


/**
 * Created by Marc Nuri &lt;marc@marcnuri.com&gt; on 2018-10-07.
 */
@Service
@RequestScope
public class SmtpService {

<span class="fc" id="L93">    private static final Logger log = LoggerFactory.getLogger(SmtpService.class);</span>

    private static final String IMAP_PROTOCOL = &quot;imap&quot;;
    private static final String IMAPS_PROTOCOL = &quot;imaps&quot;;
    private static final String SMTP_PROTOCOL = &quot;smtp&quot;;
    private static final String SMTPS_PROTOCOL = &quot;smtps&quot;;
<span class="fc" id="L99">    private static final Pattern DATA_URI_IMAGE_PATTERN = Pattern.compile(&quot;\&quot;data:(image\\/[^;]*?);base64,([^\\\&quot;]*?)\&quot;&quot;);</span>
    private static final String STYLES =
            &quot;body {font-family: 'Roboto', 'Calibri',  sans-serif; font-size: 1rem; color: #333}&quot; +
            &quot;h1 {margin: 6px 0 16px 0; font-size: 3rem; font-weight: normal}&quot; +
            &quot;h2 {margin: 6px 0 12px 0; font-size: 2.5rem; font-weight: normal}&quot; +
            &quot;h3 {margin: 6px 0 8px 0; font-size: 1.5rem; font-weight: bold}&quot; +
            &quot;blockquote {border-left: 5px solid #ebebeb; font-style: italic; margin: 0; padding: 0 32px}&quot; +
            &quot;pre.code {background-color: #ebebeb; margin: 0; padding: 8px}&quot;;

    private final MailSSLSocketFactory mailSSLSocketFactory;

    private Session session;
    private Transport smtpTransport;
    public Credentials originalCredentials;
    public String sentFolderName;

    @Autowired
<span class="fc" id="L116">    public SmtpService(MailSSLSocketFactory mailSSLSocketFactory) {</span>
<span class="fc" id="L117">        this.mailSSLSocketFactory = mailSSLSocketFactory;</span>
<span class="fc" id="L118">    }</span>

    /**
     * Checks if specified {@link Credentials} are valid
     *
     * @param credentials to validate
     * @throws AuthenticationException if credentials are not valid
     */
    public void checkCredentials(Credentials credentials) {
        try {
<span class="fc" id="L128">            getSmtpTransport(credentials);</span>
<span class="fc" id="L129">        } catch (MessagingException e) {</span>
<span class="fc" id="L130">            throw new AuthenticationException(SMTP);</span>
<span class="fc" id="L131">        }</span>
<span class="fc" id="L132">    }</span>

    public Boolean autoSentFolder( Address[] provider){

<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (provider.length &gt; 0){</span>
<span class="nc" id="L137">            String email = provider[0].toString();</span>
<span class="nc" id="L138">            log.info(&quot;Address: &quot; + email);</span>
<span class="nc bnc" id="L139" title="All 6 branches missed.">            if (email.contains(&quot;@gmail.com&quot;) || email.contains(&quot;@outlook.com&quot;) || email.contains(&quot;@hotmail.com&quot;) </span>
<span class="nc bnc" id="L140" title="All 4 branches missed.">                || email.contains(&quot;@lefebvre.es&quot;) || email.contains(&quot;@lefebvreelderecho.com&quot;)){</span>
<span class="nc" id="L141">                log.info(&quot;Provider stores in sent Folder automatically&quot;);</span>
<span class="nc" id="L142">                return true;</span>
            }
<span class="nc" id="L144">            log.info(&quot;Provider doesn't store in sent Folder automatically. Doing it Manually&quot;);</span>
        }
<span class="nc" id="L146">        return false;</span>
    }


    // private static RFC822DATA getRFC822Message(final IMAPFolder folder, final long uid) throws MessagingException{
    //     return (RFC822DATA) folder.doCommand(new IMAPFolder.ProtocolCommand(){
    //         public Object doCommand(IMAPProtocol p) throws IsotopeException{
    //             Response[] r = p.command(&quot;UID FETCH &quot; + uid + &quot; (RFC822)&quot;, null);
    //             Response response = r[r.length - 1];
    //             if (!response.isOK())
    //             {
    //                 throw new IsotopeException(&quot;Unable to retrieve message in RFC822 format&quot;);
    //             }

    //             FetchResponse fetchResponse = (FetchResponse) r[0];
    //             return fetchResponse.getItem(RFC822DATA.class);
    //         }
    //     });
    // }

    private Boolean getSentMessage(final IMAPFolder folder, final String messageId, final String subject) throws MessagingException{
<span class="nc" id="L167">        log.debug(&quot;getSentMessage&quot;);</span>
<span class="nc" id="L168">        return (Boolean) folder.doCommand( new IMAPFolder.ProtocolCommand(){</span>
            public Object doCommand(IMAPProtocol p)
            {
<span class="nc" id="L171">                log.debug(&quot;FolderName--&gt; getFullName:&quot; + folder.getFullName() + &quot;--&gt; getName:&quot; + folder.getName());</span>
<span class="nc" id="L172">                log.debug(&quot;Message-Id--&gt; &quot; + messageId);</span>
<span class="nc" id="L173">                log.debug(&quot;Subject--&gt; &quot; + subject);               </span>

<span class="nc" id="L175">                Response[] r = p.command(&quot;UID SEARCH HEADER Message-ID &quot; + messageId, null);</span>
                // Ejemplos de respuesta:
                // Encontrado gmail: * SEARCH 14, Z17 OK SEARCH completed (Success)
                // Encontrado Outlook: * SEARCH 14, D16 OK SEARCH completed.
                // Encontrado Ionos: * SEARCH, * 52 EXISTS, * 1 RECENT, BQ10 OK UID SEARCH completed
                // No encontrado: * SEARCH, P11 OK UID SEARCH completed

<span class="nc" id="L182">                log.debug(Arrays.deepToString(r));</span>

<span class="nc" id="L184">                List&lt;Response&gt; a = Arrays.asList(r);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                if (a.size() &gt; 0) {</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                    for (int i = 0; i &lt; a.size(); i++){</span>
<span class="nc" id="L187">                        log.debug(i + &quot; &quot; + a.get(i).toString());</span>
                        String[] values;
<span class="nc bnc" id="L189" title="All 2 branches missed.">                        if (a.get(i).toString().contains(&quot;* SEARCH&quot;)){</span>
<span class="nc" id="L190">                            values = a.get(i).toString().split(&quot; &quot;);</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                            for (int z = 0; z &lt; values.length; z++){</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                                if (isNumeric(values[z])){</span>
<span class="nc" id="L193">                                 return true;</span>
                                }
                            }
<span class="nc bnc" id="L196" title="All 2 branches missed.">                        } else if (a.get(i).toString().contains(&quot;EXISTS&quot;)){</span>
<span class="nc" id="L197">                            values = a.get(i).toString().split(&quot; &quot;);</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">                            for (int z = 0; z &lt; values.length; z++){</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">                                if (isNumeric(values[z])){</span>
<span class="nc" id="L200">                                 return true;</span>
                                }
                            }
                        }
                    }
                }
<span class="nc" id="L206">                return false;</span>
            }
        });
    }

    public static boolean isNumeric(String str) {
<span class="nc" id="L212">        return str.matches(&quot;-?\\d+(\\.\\d+)?&quot;);  //match a number with optional '-' and decimal.</span>
    }

    private void copyMsgToSentFolder(MimeMessage msg){
        //log.info(&quot;ImapStore:&quot; + imapStore.toString());
        try {
            //log.info(&quot;STORE SENT MESSAGE BEGINNING&quot; );
            final Session session;
            IMAPStore imapStore;
            Folder folder;
            IMAPFolder ifolder;
            
<span class="nc" id="L224">            session = Session.getInstance(initMailPropertiesImap(originalCredentials, mailSSLSocketFactory), null);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            imapStore = (IMAPStore) session.getStore(originalCredentials.getImapSsl() ? IMAPS_PROTOCOL : IMAP_PROTOCOL);</span>
<span class="nc" id="L226">            imapStore.connect(</span>
<span class="nc" id="L227">                originalCredentials.getServerHost(),</span>
<span class="nc" id="L228">                originalCredentials.getServerPort(),</span>
<span class="nc" id="L229">                originalCredentials.getUser(),</span>
<span class="nc" id="L230">                originalCredentials.getPassword());</span>

<span class="nc" id="L232">            folder = imapStore.getDefaultFolder();</span>

            //Get sentFolderName
<span class="nc" id="L235">            processFolderElements(folder, false, &quot;&quot;);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            if ((folder.getType() &amp; Folder.HOLDS_FOLDERS) != 0) {</span>
<span class="nc" id="L237">                Folder[] f = folder.list(&quot;%&quot;);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                for (int i = 0; i &lt; f.length; i++)</span>
<span class="nc" id="L239">                processFolderElements(f[i], true, &quot;    &quot;);</span>
            }

            //log.info(&quot;Sent folder Name: &quot; + sentFolderName);

            //folder = imapStore.getFolder(sentFolderName);
<span class="nc" id="L245">            ifolder = (IMAPFolder) imapStore.getFolder(sentFolderName);</span>

<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (ifolder == null){</span>
<span class="nc" id="L248">                log.debug(&quot;Error obteniendo el folder&quot;);</span>
            } 
            else {
<span class="nc" id="L251">                ifolder.open(Folder.READ_WRITE);</span>

<span class="nc" id="L253">                javax.mail.Message[] msgs = new javax.mail.Message[1];</span>
<span class="nc" id="L254">                msgs[0] = msg;</span>
<span class="nc" id="L255">                msgs[0].setFlag(Flags.Flag.SEEN, true);</span>
                
<span class="nc bnc" id="L257" title="All 2 branches missed.">                if  (!getSentMessage(ifolder, msgs[0].getHeader(&quot;Message-Id&quot;)[0], msgs[0].getHeader(&quot;Subject&quot;)[0])){</span>
<span class="nc" id="L258">                    log.debug(&quot;Copying message to sent folder&quot;);</span>
<span class="nc" id="L259">                    ifolder.appendMessages(msgs);</span>
                }
                else {
<span class="nc" id="L262">                    log.debug(&quot;Message automatically stored in sent folder by email provider&quot;);</span>
                }

<span class="nc" id="L265">                ifolder.close(true);</span>
            }
            
<span class="nc" id="L268">            imapStore.close();</span>
<span class="nc" id="L269">        } catch (Exception e) {</span>
            //log.info(&quot;Error de los buenos&quot;);
<span class="nc" id="L271">            throw new IsotopeException(&quot;Problem leaving a copy of the message in Sent Folder&quot;, e);</span>
<span class="nc" id="L272">        }</span>
<span class="nc" id="L273">    }</span>

    String sendMessage(HttpServletRequest request, Message message) {
        try {
<span class="fc" id="L277">            final Credentials credentials = getCredentials();</span>
<span class="fc" id="L278">            final Charset currentCharset = Charset.defaultCharset();</span>
<span class="fc" id="L279">            final MimeMessage mimeMessage = new MimeMessage(getSession(credentials));</span>
<span class="fc" id="L280">            final Transport smtpTransport = getSmtpTransport(credentials); </span>
<span class="fc" id="L281">            final TransportListener transportListener = new TransportListener(){</span>
            
                @Override
                public void messagePartiallyDelivered(TransportEvent e) {
<span class="nc" id="L285">                    log.debug(&quot;messagePartiallyDelivered&quot;);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">                    if (e.getValidSentAddresses().length &gt; 0){</span>
                        try {
<span class="nc" id="L288">                            copyMsgToSentFolder(mimeMessage);                            </span>
<span class="nc" id="L289">                        } catch(Exception ex) {</span>
<span class="nc" id="L290">                            throw new IsotopeException(&quot;Problem storing copy of message: messagePartiallyDelivered&quot;, ex);</span>
<span class="nc" id="L291">                        }</span>
                    }
<span class="nc" id="L293">                }</span>
            
                @Override
                public void messageNotDelivered(TransportEvent e) {
<span class="nc" id="L297">                    log.debug(&quot;messageNotDelivered&quot;);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                    if (e.getValidSentAddresses().length &gt; 0){</span>
                        try {
<span class="nc" id="L300">                            copyMsgToSentFolder(mimeMessage);                         </span>
<span class="nc" id="L301">                        } catch (Exception ex) {</span>
<span class="nc" id="L302">                            throw new IsotopeException(&quot;Problem storing copy of message: messageNotDelivered &quot;, ex);</span>
<span class="nc" id="L303">                        }</span>
                    }
<span class="nc" id="L305">                }</span>
            
                @Override
                public void messageDelivered(TransportEvent e) {
<span class="nc" id="L309">                    log.debug(&quot;messageDelivered&quot;);</span>
                    try {
<span class="nc" id="L311">                        log.debug(&quot;MessageID:&quot; + e.getMessage().getHeader(&quot;Message-ID&quot;)[0]);</span>
<span class="nc" id="L312">                    } catch (Exception ex) {</span>
<span class="nc" id="L313">                        throw new IsotopeException(&quot;Problem getting deliverd message-id&quot;, ex);</span>
<span class="nc" id="L314">                    }</span>
                    try {
<span class="nc" id="L316">                        copyMsgToSentFolder(mimeMessage);</span>
<span class="nc" id="L317">                    } catch (Exception ex) {</span>
<span class="nc" id="L318">                        throw new IsotopeException(&quot;Problem storing copy of message: messageDelivered&quot; , ex);</span>
<span class="nc" id="L319">                    }</span>
<span class="nc" id="L320">                }</span>
            };
<span class="fc" id="L322">            mimeMessage.setSentDate(new Date());</span>
<span class="pc bpc" id="L323" title="1 of 4 branches missed.">            if (credentials.getUser() != null &amp;&amp; credentials.getUser().contains(&quot;@&quot;)) {</span>
<span class="fc" id="L324">                mimeMessage.setFrom(credentials.getUser());</span>
            } else {
<span class="fc" id="L326">                mimeMessage.setFrom(String.format(&quot;%s@%s&quot;, credentials.getUser(), credentials.getServerHost()));</span>
            }
<span class="fc bfc" id="L328" title="All 2 branches covered.">            for (javax.mail.Message.RecipientType type : new javax.mail.Message.RecipientType[]{</span>
                    MimeMessage.RecipientType.TO, MimeMessage.RecipientType.CC, MimeMessage.RecipientType.BCC
            }) {
<span class="fc" id="L331">                mimeMessage.setRecipients(type, MessageUtils.getRecipientAddresses(message, type));</span>
            }
<span class="fc" id="L333">            mimeMessage.setSubject(message.getSubject(), currentCharset.name());</span>

<span class="pc bpc" id="L335" title="1 of 2 branches missed.">            if (message.getInReplyTo() != null) {</span>
<span class="nc" id="L336">                mimeMessage.setHeader(HEADER_IN_REPLY_TO, String.join(&quot; &quot;, message.getInReplyTo()));</span>
            }
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">            if (message.getReferences() != null) {</span>
<span class="nc" id="L339">                mimeMessage.setHeader(HEADER_REFERENCES, String.join(&quot; &quot;, message.getReferences()));</span>
            }

<span class="fc" id="L342">            final MimeMultipart multipart = new MimeMultipart();</span>

            // Extract data-uri images to inline attachments
<span class="fc" id="L345">            final String originalContent = message.getContent();</span>
<span class="fc" id="L346">            String finalContent = originalContent;</span>
<span class="fc" id="L347">            final Matcher matcher = DATA_URI_IMAGE_PATTERN.matcher(originalContent);</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">            while(matcher.find()) {</span>
<span class="nc" id="L349">                final String cid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);</span>
<span class="nc" id="L350">                final String contentType = matcher.group(1);</span>
<span class="nc" id="L351">                final InternetHeaders headers = new InternetHeaders();</span>
<span class="nc" id="L352">                headers.addHeader(&quot;Content-Type&quot;, contentType);</span>
<span class="nc" id="L353">                headers.addHeader(&quot;Content-Transfer-Encoding&quot;, &quot;base64&quot;);</span>
<span class="nc" id="L354">                final MimeBodyPart cidImagePart = new MimeBodyPart(headers, matcher.group(2).getBytes());</span>
<span class="nc" id="L355">                multipart.addBodyPart(cidImagePart);</span>
<span class="nc" id="L356">                cidImagePart.setDisposition(MimeBodyPart.INLINE);</span>
<span class="nc" id="L357">                cidImagePart.setContentID(String.format(&quot;&lt;%s&gt;&quot;,cid));</span>
<span class="nc" id="L358">                cidImagePart.setFileName(String.format(&quot;%s.%s&quot;, cid, contentType.substring(contentType.indexOf('/') + 1)));</span>
<span class="nc" id="L359">                finalContent = finalContent.replace(matcher.group(), &quot;\&quot;cid:&quot; +cid +&quot;\&quot;&quot;);</span>
<span class="nc" id="L360">            }</span>

            // Include attachments
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">            if (message.getAttachments() != null &amp;&amp; !message.getAttachments().isEmpty()) {</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">                for (Attachment attachment : message.getAttachments()) {</span>
<span class="fc" id="L365">                    multipart.addBodyPart(toBodyPart(request, attachment));</span>
<span class="fc" id="L366">                }</span>
            }

            // Create body part
<span class="fc" id="L370">            final MimeBodyPart body = new MimeBodyPart();</span>
<span class="fc" id="L371">            multipart.addBodyPart(body);</span>
<span class="fc" id="L372">            body.setContent(new String(String.format(&quot;&lt;html&gt;&lt;head&gt;&lt;style&gt;%1$s&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id='scoped'&gt;&quot;</span>
                            + &quot;&lt;style type='text/css' scoped&gt;%1$s&lt;/style&gt;%2$s&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;,
<span class="fc" id="L374">                            STYLES, finalContent).getBytes(), currentCharset),</span>
<span class="fc" id="L375">                    String.format(&quot;%s; charset=\&quot;%s\&quot;&quot;, MediaType.TEXT_HTML_VALUE, currentCharset.name()));</span>
<span class="fc" id="L376">            mimeMessage.setContent(multipart);</span>
<span class="fc" id="L377">            mimeMessage.saveChanges();</span>

<span class="fc" id="L379">            String[] messageId = mimeMessage.getHeader(&quot;Message-Id&quot;);</span>
<span class="fc" id="L380">            smtpTransport.addTransportListener(transportListener);</span>

<span class="fc" id="L382">            smtpTransport.sendMessage(mimeMessage, mimeMessage.getAllRecipients());</span>

<span class="fc" id="L384">            log.info(&quot;Sending Message: &quot; + messageId[0].toString());</span>
                        
<span class="fc" id="L386">            return messageId[0];</span>
<span class="nc" id="L387">        } catch(MessagingException | IOException ex) {</span>
<span class="nc" id="L388">            throw new IsotopeException(&quot;Problem sending message&quot;, ex);</span>
        }
    }

    @PreDestroy
    public void destroy() {
<span class="fc" id="L394">        log.debug(&quot;SmtpService destroyed&quot;);</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        if(smtpTransport != null) {</span>
            try {
<span class="nc" id="L397">                smtpTransport.close();</span>
<span class="nc" id="L398">            } catch (MessagingException ex) {</span>
<span class="nc" id="L399">                log.error(&quot;Error closing SMTP Transport&quot;, ex);</span>
<span class="nc" id="L400">            }</span>
        }
<span class="fc" id="L402">    }</span>

    private Session getSession(Credentials credentials) {
<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (session == null) {</span>
<span class="fc" id="L406">            originalCredentials = credentials;</span>
<span class="fc" id="L407">            session = Session.getInstance(initMailProperties(credentials, mailSSLSocketFactory), null);</span>
        }
<span class="fc" id="L409">        return session;</span>
    }

    private Transport getSmtpTransport(Credentials credentials) throws MessagingException {
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        if (smtpTransport == null) {</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            smtpTransport = getSession(credentials).getTransport(credentials.getSmtpSsl() ? SMTPS_PROTOCOL : SMTP_PROTOCOL);</span>
<span class="fc" id="L415">            final String smtpHost = credentials.getSmtpHost();</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            smtpTransport.connect(</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">                    smtpHost != null &amp;&amp; !smtpHost.isEmpty() ? smtpHost : credentials.getServerHost(),</span>
<span class="fc" id="L418">                    credentials.getSmtpPort(),</span>
<span class="fc" id="L419">                    credentials.getUser(),</span>
<span class="fc" id="L420">                    credentials.getPassword());</span>
<span class="fc" id="L421">            log.debug(&quot;Opened new SMTP transport&quot;);</span>
        }
<span class="fc" id="L423">        return smtpTransport;</span>
    }

    private Credentials getCredentials() {
<span class="fc" id="L427">        return (Credentials)SecurityContextHolder.getContext().getAuthentication();</span>
    }

    private static Properties initMailProperties(Credentials credentials, MailSSLSocketFactory socketFactory) {
<span class="fc" id="L431">        final Properties ret = new Properties();</span>
<span class="fc" id="L432">        ret.put(&quot;mail.smtp.ssl.enable&quot;, credentials.getSmtpSsl());</span>
<span class="fc" id="L433">        ret.put(&quot;mail.smtp.connectiontimeout&quot;, DEFAULT_CONNECTION_TIMEOUT);</span>
<span class="fc" id="L434">        ret.put(&quot;mail.smtp.ssl.socketFactory&quot;, socketFactory);</span>
<span class="fc" id="L435">        ret.put(&quot;mail.smtp.starttls.enable&quot;, credentials.getSmtpTls());</span>
<span class="fc" id="L436">        ret.put(&quot;mail.smtp.starttls.required&quot;, false);</span>
<span class="fc" id="L437">        ret.put(&quot;mail.smtps.connectiontimeout&quot;, DEFAULT_CONNECTION_TIMEOUT);</span>
<span class="fc" id="L438">        ret.put(&quot;mail.smtps.socketFactory&quot;, socketFactory);</span>
<span class="fc" id="L439">        ret.put(&quot;mail.smtps.ssl.socketFactory&quot;, socketFactory);</span>
<span class="fc" id="L440">        ret.put(&quot;mail.smtps.socketFactory.fallback&quot;, false);</span>
<span class="fc" id="L441">        ret.put(&quot;mail.smtps.auth&quot;, true);</span>
<span class="fc" id="L442">        return ret;</span>
    }

    private static Properties initMailPropertiesImap(Credentials credentials, MailSSLSocketFactory mailSSLSocketFactory) {
<span class="nc" id="L446">        final Properties ret = new Properties();</span>
<span class="nc" id="L447">        ret.put(&quot;mail.imap.ssl.enable&quot;, credentials.getImapSsl());</span>
<span class="nc" id="L448">        ret.put(&quot;mail.imap.connectiontimeout&quot;, DEFAULT_CONNECTION_TIMEOUT);</span>
<span class="nc" id="L449">        ret.put(&quot;mail.imap.connectionpooltimeout&quot;, DEFAULT_CONNECTION_TIMEOUT);</span>
<span class="nc" id="L450">        ret.put(&quot;mail.imap.ssl.socketFactory&quot;, mailSSLSocketFactory);</span>
<span class="nc" id="L451">        ret.put(&quot;mail.imap.starttls.enable&quot;, true);</span>
<span class="nc" id="L452">        ret.put(&quot;mail.imap.starttls.required&quot;, false);</span>
<span class="nc" id="L453">        ret.put(&quot;mail.imaps.socketFactory&quot;, mailSSLSocketFactory);</span>
<span class="nc" id="L454">        ret.put(&quot;mail.imaps.socketFactory.fallback&quot;, false);</span>
<span class="nc" id="L455">        ret.put(&quot;mail.imaps.ssl.socketFactory&quot;, mailSSLSocketFactory);</span>
<span class="nc" id="L456">        return ret;</span>
    }

    private static MimeBodyPart toBodyPart(HttpServletRequest request, Attachment attachment)
            throws MessagingException, IOException {

<span class="fc" id="L462">        final MimeBodyPart mimeAttachment = new MimeBodyPart();</span>
<span class="fc" id="L463">        mimeAttachment.setDisposition(MimeBodyPart.ATTACHMENT);</span>
<span class="pc bpc" id="L464" title="1 of 4 branches missed.">        final String mimeType = attachment.getContentType() != null &amp;&amp; !attachment.getContentType().isEmpty() ?</span>
<span class="fc" id="L465">                attachment.getContentType() : MediaType.APPLICATION_OCTET_STREAM_VALUE;</span>
        final DataSource dataSource;
<span class="fc bfc" id="L467" title="All 2 branches covered.">        if (attachment.getContent() != null) {</span>
<span class="fc" id="L468">            dataSource = new ByteArrayDataSource(attachment.getContent(), mimeType);</span>
        } else {
<span class="fc" id="L470">            dataSource = new IsotopeURLDataSource(attachment.getLink(REL_DOWNLOAD).getTemplate().expand().toURL(),</span>
                    mimeType, request);
        }
<span class="fc" id="L473">        mimeAttachment.setDataHandler(new DataHandler(dataSource));</span>
<span class="fc" id="L474">        mimeAttachment.setFileName(MimeUtility.encodeText(attachment.getFileName()));</span>
<span class="fc" id="L475">        return mimeAttachment;</span>
    }


    private void processFolderElements(Folder folder, boolean recurse, String tab)
					throws Exception {
        // Uncomment this section to debug:
        // log.info(tab + &quot;Name:      &quot; + folder.getName());
        // log.info(tab + &quot;Full Name: &quot; + folder.getFullName());
        // log.info(tab + &quot;URL:       &quot; + folder.getURLName());
        // if (!folder.isSubscribed())
        // log.info(tab + &quot;Not Subscribed&quot;);
        // if ((folder.getType() &amp; Folder.HOLDS_MESSAGES) != 0) {
        //     if (folder.hasNewMessages())
        //         log.info(tab + &quot;Has New Messages&quot;);
        //     log.info(tab + &quot;Total Messages:  &quot; + folder.getMessageCount());
        //     log.info(tab + &quot;New Messages:    &quot; + folder.getNewMessageCount());
        //     log.info(tab + &quot;Unread Messages: &quot; + folder.getUnreadMessageCount());
        // }
        // if ((folder.getType() &amp; Folder.HOLDS_FOLDERS) != 0)
        //     log.info(tab + &quot;Is Directory&quot;);

<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (folder instanceof IMAPFolder) {</span>
<span class="nc" id="L498">            IMAPFolder f = (IMAPFolder)folder;</span>
<span class="nc" id="L499">            String[] attrs = f.getAttributes();</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">            if (attrs != null &amp;&amp; attrs.length &gt; 0) {</span>
                //log.info(tab + &quot;IMAP Attributes:&quot;);
<span class="nc bnc" id="L502" title="All 2 branches missed.">                for (int i = 0; i &lt; attrs.length; i++){</span>
                    //log.info(tab + &quot;    &quot; + attrs[i]);
<span class="nc bnc" id="L504" title="All 2 branches missed.">                    if (&quot;\\Sent&quot;.equals(attrs[i])){</span>
                        //log.info(&quot;Localizado el folder de enviados &quot;);
<span class="nc" id="L506">                        sentFolderName = f.getFullName();</span>
                    }
                }
            }
        }
        //log.info(&quot;***&quot;);
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if ((folder.getType() &amp; Folder.HOLDS_FOLDERS) != 0) {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">            if (recurse) {</span>
<span class="nc" id="L514">            Folder[] f = folder.list();</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            for (int i = 0; i &lt; f.length; i++)</span>
<span class="nc" id="L516">            processFolderElements(f[i], recurse, tab + &quot;    &quot;);</span>
            }
        }
<span class="nc" id="L519">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>