<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ImapService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">api</a> &gt; <a href="index.source.html" class="el_package">com.marcnuri.isotope.api.imap</a> &gt; <span class="el_source">ImapService.java</span></div><h1>ImapService.java</h1><pre class="source lang-java linenums">/*
 * ImapService.java
 *
 * Created on 2018-08-08, 16:34
 *
 * Copyright 2018 Marc Nuri
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.marcnuri.isotope.api.imap;

import com.marcnuri.isotope.api.configuration.IsotopeApiConfiguration;
import com.marcnuri.isotope.api.credentials.Credentials;
import com.marcnuri.isotope.api.credentials.CredentialsService;
import com.marcnuri.isotope.api.exception.AuthenticationException;
import com.marcnuri.isotope.api.exception.InvalidFieldException;
import com.marcnuri.isotope.api.exception.IsotopeException;
import com.marcnuri.isotope.api.exception.NotFoundException;
import com.marcnuri.isotope.api.folder.Folder;
import com.marcnuri.isotope.api.folder.FolderUtils;
import com.marcnuri.isotope.api.message.Attachment;
import com.marcnuri.isotope.api.message.Message;
import com.marcnuri.isotope.api.message.MessageWithFolder;
import com.sun.mail.imap.IMAPFolder;
import com.sun.mail.imap.IMAPMessage;
import com.sun.mail.imap.IMAPStore;
import com.sun.mail.util.MailSSLSocketFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Primary;
import org.springframework.http.MediaType;
import org.springframework.http.codec.ServerSentEvent;
import org.springframework.lang.NonNull;
import org.springframework.lang.Nullable;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.web.context.annotation.RequestScope;
import org.apache.tomcat.util.codec.binary.Base64;
import reactor.core.publisher.Flux;

import javax.annotation.PreDestroy;
import javax.mail.BodyPart;
import javax.mail.Flags;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.Part;
import javax.mail.Session;
import javax.mail.UIDFolder;
import javax.mail.URLName;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeUtility;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.Properties;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.marcnuri.isotope.api.configuration.IsotopeApiConfiguration.DEFAULT_CONNECTION_TIMEOUT;
import static com.marcnuri.isotope.api.exception.AuthenticationException.Type.IMAP;
import static com.marcnuri.isotope.api.folder.FolderResource.addLinks;
import static com.marcnuri.isotope.api.folder.FolderUtils.addSystemFolders;
import static com.marcnuri.isotope.api.folder.FolderUtils.getFileWithRef;
import static com.marcnuri.isotope.api.message.MessageUtils.envelopeFetch;
import static com.marcnuri.isotope.api.message.MessageUtils.extractBodypart;
import static com.marcnuri.isotope.api.message.MessageUtils.extractContent;
import static com.marcnuri.isotope.api.message.MessageUtils.replaceEmbeddedImage;
import static javax.mail.Folder.READ_ONLY;
import static javax.mail.Folder.READ_WRITE;

/**
 * Created by Marc Nuri &lt;marc@marcnuri.com&gt; on 2018-08-08.
 */
@Service
@RequestScope
@Primary
@SuppressWarnings(&quot;squid:S4529&quot;)
public class ImapService {

<span class="fc" id="L98">    private static final Logger log = LoggerFactory.getLogger(ImapService.class);</span>

    private static final String IMAP_PROTOCOL = &quot;imap&quot;;
    private static final String IMAPS_PROTOCOL = &quot;imaps&quot;;
    static final String IMAP_CAPABILITY_CONDSTORE = &quot;CONDSTORE&quot;;
    public static final String MULTIPART_MIME_TYPE = &quot;multipart/&quot;;
    static final int DEFAULT_INITIAL_MESSAGES_BATCH_SIZE = 20;
    static final int DEFAULT_MAX_MESSAGES_BATCH_SIZE = 640;

    private final IsotopeApiConfiguration isotopeApiConfiguration;
    private final MailSSLSocketFactory mailSSLSocketFactory;
    private final CredentialsService credentialsService;

    private IMAPStore imapStore;

    @Autowired
    public ImapService(
            IsotopeApiConfiguration isotopeApiConfiguration, MailSSLSocketFactory mailSSLSocketFactory,
<span class="fc" id="L116">            CredentialsService credentialsService) {</span>

<span class="fc" id="L118">        this.isotopeApiConfiguration = isotopeApiConfiguration;</span>
<span class="fc" id="L119">        this.mailSSLSocketFactory = mailSSLSocketFactory;</span>
<span class="fc" id="L120">        this.credentialsService = credentialsService;</span>
<span class="fc" id="L121">    }</span>

    /**
     * Checks if specified {@link Credentials} are valid and returns a new Credentials object with
     * encrypted values.
     *
     * @param credentials to validate
     * @return credentials object with encrypted values
     */
    public Credentials checkCredentials(Credentials credentials) {
        try {
<span class="nc" id="L132">            credentialsService.checkHost(credentials);</span>
<span class="nc" id="L133">            getImapStore(credentials).getDefaultFolder();</span>
<span class="nc" id="L134">            return credentialsService.encrypt(credentials);</span>
<span class="nc" id="L135">        } catch (MessagingException | IOException e) {</span>
<span class="nc" id="L136">            throw new AuthenticationException(IMAP);</span>
        }
    }

    public List&lt;Folder&gt; getFolders(@Nullable Boolean loadChildren) {
        try {
<span class="nc" id="L142">            final IMAPFolder rootFolder = (IMAPFolder)getImapStore().getDefaultFolder();</span>
<span class="nc" id="L143">            final List&lt;Folder&gt; folders = Stream.of(rootFolder.list())</span>
<span class="nc" id="L144">                    .map(IMAPFolder.class::cast)</span>
<span class="nc" id="L145">                    .map(mf -&gt; Folder.from(mf, loadChildren))</span>
<span class="nc" id="L146">                    .sorted(Comparator.comparing(Folder::getName))</span>
<span class="nc" id="L147">                    .collect(Collectors.toList());</span>
<span class="nc" id="L148">            addSystemFolders(rootFolder, folders);</span>
            // Clear \Recent flags by opening and closing the INBOX
<span class="nc bnc" id="L150" title="All 2 branches missed.">            if (folders.stream().anyMatch(</span>
<span class="nc bnc" id="L151" title="All 4 branches missed.">                    f -&gt; f.getName().equalsIgnoreCase(&quot;INBOX&quot;) &amp;&amp; f.getNewMessageCount() &gt; 0)) {</span>
<span class="nc" id="L152">                final IMAPFolder inbox = (IMAPFolder)rootFolder.getFolder(&quot;INBOX&quot;);</span>
<span class="nc" id="L153">                inbox.open(READ_WRITE);</span>
<span class="nc" id="L154">                inbox.getNewMessageCount();</span>
<span class="nc" id="L155">                inbox.close();</span>
            }
<span class="nc" id="L157">            return folders;</span>
<span class="nc" id="L158">        } catch (MessagingException ex) {</span>
<span class="nc" id="L159">            log.error(&quot;Error loading folders&quot;, ex);</span>
<span class="nc" id="L160">            throw new IsotopeException(ex.getMessage());</span>
        }
    }

    /**
     * Creates a new folder in the 1st level of the user's mailbox (root level)
     *
     * @param newFolderName name for the folder to be created
     * @return List of 1st level folders with the new folder included
     */
    public List&lt;Folder&gt; createRootFolder(@NonNull String newFolderName) {
        try {
<span class="fc" id="L172">            final IMAPFolder rootFolder = (IMAPFolder)getImapStore().getDefaultFolder();</span>
<span class="fc" id="L173">            final IMAPFolder newFolder = (IMAPFolder)rootFolder.getFolder(newFolderName);</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">            if (!newFolder.exists()) {</span>
<span class="fc" id="L175">                newFolder.create(IMAPFolder.HOLDS_MESSAGES | IMAPFolder.HOLDS_FOLDERS);</span>
            }
<span class="fc" id="L177">            return Arrays.asList(Folder.from(rootFolder, true).getChildren());</span>
<span class="nc" id="L178">        } catch (MessagingException ex) {</span>
<span class="nc" id="L179">            log.error(&quot;Error creating new root folder {}&quot;, newFolderName, ex);</span>
<span class="nc" id="L180">            throw new IsotopeException(ex.getMessage());</span>
        }
    }

    /**
     * Creates a new folder in the 1st level of the user's mailbox (root level)
     *
     * @param parentFolderId Id of the folder to which to add the new child
     * @param newFolderName name for the folder to be created
     * @return Updated parent folder with child folders with the new folder included
     */
    public Folder createChildFolder(@NonNull  URLName parentFolderId, @NonNull String newFolderName) {

        try {
<span class="fc" id="L194">            final IMAPFolder parentFolder = getFolder(parentFolderId);</span>
<span class="fc" id="L195">            final IMAPFolder newFolder = (IMAPFolder)parentFolder.getFolder(newFolderName);</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">            if (!newFolder.exists()) {</span>
<span class="fc" id="L197">                newFolder.create(IMAPFolder.HOLDS_MESSAGES | IMAPFolder.HOLDS_FOLDERS);</span>
            }
            // Must fetch folder again as attributes for the folder have changed and are cached in IMAPFolder
<span class="fc" id="L200">            return Folder.from(getFolder(parentFolderId), true);</span>
<span class="nc" id="L201">        } catch (MessagingException ex) {</span>
<span class="nc" id="L202">            log.error(&quot;Error creating new folder {} under {}&quot;, newFolderName, parentFolderId, ex);</span>
<span class="nc" id="L203">            throw new IsotopeException(ex.getMessage());</span>
        }
    }

    /**
     * Renames the folder with the provided {@link URLName} to the specified newName.
     *
     * &lt;p&gt;The newName must not contain the folder separator character.
     *
     * @param folderToRenameId Id of the folder to rename
     * @param newName New name for the provided folder Id
     * @return Folder with containing metadata from the parent of the renamed folder and all of its children
     */
    public Folder renameFolder(URLName folderToRenameId, @NonNull String newName) {
        try {
<span class="nc" id="L218">            final IMAPFolder folder = getFolder(folderToRenameId);</span>
<span class="nc" id="L219">            newName = newName.replaceAll(&quot;[.\\[\\]/\\\\&amp;~*]&quot;, &quot;&quot;); /// Sanitize name</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">            if (newName.isEmpty() || newName.indexOf(folder.getSeparator()) &gt;= 0) {</span>
<span class="nc" id="L221">                throw new InvalidFieldException(&quot;New folder name contains invalid characters&quot;);</span>
            }
<span class="nc" id="L223">            final String folderToRenameFullName = folder.getFullName();</span>
<span class="nc" id="L224">            final String newFolderFullName = String.format(&quot;%s%s&quot;,</span>
<span class="nc" id="L225">                    folderToRenameFullName.substring(0, folderToRenameFullName.lastIndexOf(folder.getName())),</span>
                    newName
            );
<span class="nc" id="L228">            return FolderUtils.renameFolder(folder, newFolderFullName);</span>
<span class="nc" id="L229">        } catch (MessagingException ex) {</span>
<span class="nc" id="L230">            log.error(&quot;Error renaming folder &quot; + folderToRenameId.toString(), ex);</span>
<span class="nc" id="L231">            throw new IsotopeException(ex.getMessage());</span>
        }
    }

    /**
     * Moves the folder with the provided {@link URLName} to the specified target folder with the provided
     * URLName or to the first level if the target folder is null.
     *
     * &lt;p&gt;Both folders must exist in order for the action to complete successfully.
     *
     * @param folderToMoveId Id of the folder to move
     * @param targetFolderId Id of the target folder
     * @return
     */
    public Folder moveFolder(@NonNull URLName folderToMoveId, @Nullable URLName targetFolderId) {
        try {
<span class="fc" id="L247">            final IMAPFolder folderToMove = getFolder(folderToMoveId);</span>
            final String movedFolderFullName;
<span class="fc bfc" id="L249" title="All 2 branches covered.">            if (targetFolderId == null) {</span>
<span class="fc" id="L250">                movedFolderFullName = folderToMove.getName();</span>
            } else {
<span class="fc" id="L252">                final IMAPFolder targetFolder = getFolder(targetFolderId);</span>
<span class="fc" id="L253">                movedFolderFullName = String.format(&quot;%s%s%s&quot;,</span>
<span class="fc" id="L254">                        targetFolder.getFullName(), targetFolder.getSeparator(), folderToMove.getName());</span>
            }
<span class="fc" id="L256">            return FolderUtils.renameFolder(folderToMove, movedFolderFullName);</span>
<span class="fc" id="L257">        } catch (MessagingException ex) {</span>
<span class="fc" id="L258">            log.error(&quot;Error moving folder &quot; + folderToMoveId.toString(), ex);</span>
<span class="fc" id="L259">            throw new IsotopeException(ex.getMessage());</span>
        }
    }

    /**
     * Permanently deletes the folder with the provided {@link URLName} and its children.
     *
     * @param folderToDeleteId Id of the folder to delete
     * @return Parent of deleted folder
     */
    public Folder deleteFolder(@NonNull URLName folderToDeleteId) {
        try {
<span class="fc" id="L271">            final IMAPFolder folderToDelete = getFolder(folderToDeleteId);</span>
<span class="fc" id="L272">            final IMAPFolder parent = (IMAPFolder)folderToDelete.getParent();</span>
<span class="fc" id="L273">            folderToDelete.delete(true);</span>
<span class="fc" id="L274">            return Folder.from(parent, true);</span>
<span class="nc" id="L275">        } catch (MessagingException ex) {</span>
<span class="nc" id="L276">            log.error(&quot;Error deleting folder &quot; + folderToDeleteId.toString(), ex);</span>
<span class="nc" id="L277">            throw new IsotopeException(ex.getMessage());</span>
        }
    }

    public Flux&lt;ServerSentEvent&lt;List&lt;Message&gt;&gt;&gt; getMessagesFlux(URLName folderId, HttpServletResponse response) {

<span class="nc" id="L283">        return Flux.create(new MessageFluxSinkConsumer(</span>
<span class="nc" id="L284">                (Credentials)SecurityContextHolder.getContext().getAuthentication(), folderId, response,this));</span>
    }

    public MessageWithFolder getMessage(URLName folderId, Long uid) {
        try {
<span class="nc" id="L289">            final IMAPFolder folder = getFolder(folderId);</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (!folder.isOpen()) {</span>
<span class="nc" id="L291">                folder.open(READ_ONLY);</span>
            }
<span class="nc" id="L293">            final IMAPMessage imapMessage = (IMAPMessage)folder.getMessageByUID(uid);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">            if (imapMessage == null) {</span>
<span class="nc" id="L295">                folder.close();</span>
<span class="nc" id="L296">                throw new NotFoundException(&quot;Message not found&quot;);</span>
            }
<span class="nc" id="L298">            final MessageWithFolder ret = MessageWithFolder.from(folder, imapMessage);</span>
<span class="nc" id="L299">            readContentIntoMessage(folderId, imapMessage, ret);</span>
<span class="nc" id="L300">            folder.close();</span>
<span class="nc" id="L301">            return ret;</span>
<span class="nc" id="L302">        } catch (MessagingException | IOException ex) {</span>
<span class="nc" id="L303">            log.error(&quot;Error loading messages for folder: &quot; + folderId.toString(), ex);</span>
<span class="nc" id="L304">            throw  new IsotopeException(ex.getMessage());</span>
        }
    }

    public String getMessageRaw(URLName folderId, Long uid) {
        try {
<span class="nc" id="L310">            final IMAPFolder folder = getFolder(folderId);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">            if (!folder.isOpen()) {</span>
<span class="nc" id="L312">                folder.open(READ_ONLY);</span>
            }
<span class="nc" id="L314">            final IMAPMessage imapMessage = (IMAPMessage)folder.getMessageByUID(uid);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (imapMessage == null) {</span>
<span class="nc" id="L316">                folder.close();</span>
<span class="nc" id="L317">                throw new NotFoundException(&quot;Message not found&quot;);</span>
            }

<span class="nc" id="L320">            ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span>
<span class="nc" id="L321">            imapMessage.writeTo(buffer);</span>
<span class="nc" id="L322">            byte[] bytes = buffer.toByteArray();</span>
<span class="nc" id="L323">            String encodedEmail = Base64.encodeBase64URLSafeString(bytes);</span>
            
<span class="nc" id="L325">            log.debug(&quot;Mensaje sin codificar: &quot; + buffer.toString());</span>
<span class="nc" id="L326">            log.debug(&quot;Mensaje codificado Base64URL: &quot; + encodedEmail);</span>

<span class="nc" id="L328">            folder.close();</span>
<span class="nc" id="L329">            return encodedEmail;</span>
<span class="nc" id="L330">        } catch (MessagingException | IOException ex) {</span>
<span class="nc" id="L331">            log.error(&quot;Error loading raw messages for folder: &quot; + folderId.toString(), ex);</span>
<span class="nc" id="L332">            throw  new IsotopeException(ex.getMessage());</span>
        }
    }

    public List&lt;Message&gt; preloadMessages(@NonNull URLName folderId, @NonNull List&lt;Long&gt; uids) {

        try {
<span class="nc" id="L339">            final IMAPFolder folder = getFolder(folderId);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            if (!folder.isOpen()) {</span>
<span class="nc" id="L341">                folder.open(READ_ONLY);</span>
            }
<span class="nc" id="L343">            final List&lt;Message&gt; ret = new ArrayList&lt;&gt;(uids.size());</span>
<span class="nc" id="L344">            final List&lt;IMAPMessage&gt; messages = Stream.of(</span>
<span class="nc" id="L345">                    folder.getMessagesByUID(uids.stream().mapToLong(Long::longValue).toArray()))</span>
<span class="nc" id="L346">                    .filter(Objects::nonNull)</span>
<span class="nc" id="L347">                    .map(IMAPMessage.class::cast)</span>
<span class="nc" id="L348">                    .collect(Collectors.toList());</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">            for(IMAPMessage imapMessage : messages) {</span>
<span class="nc" id="L350">                final Message message = Message.from(folder, imapMessage);</span>
<span class="nc" id="L351">                ret.add(message);</span>
<span class="nc" id="L352">                imapMessage.setPeek(true);</span>
<span class="nc" id="L353">                readContentIntoMessage(folderId, imapMessage, message);</span>
<span class="nc" id="L354">            }</span>
<span class="nc" id="L355">            folder.close();</span>
<span class="nc" id="L356">            return ret;</span>
<span class="nc" id="L357">        } catch (MessagingException | IOException ex) {</span>
<span class="nc" id="L358">            throw  new IsotopeException(ex.getMessage());</span>
        }
    }

    public void readAttachment(
            HttpServletResponse response, URLName folderId, Long messageId, String id, Boolean isContentId) {

        try {
<span class="nc" id="L366">            final IMAPFolder folder = getFolder(folderId);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (!folder.isOpen()) {</span>
<span class="nc" id="L368">                folder.open(READ_ONLY);</span>
            }
<span class="nc" id="L370">            final IMAPMessage imapMessage = (IMAPMessage)folder.getMessageByUID(messageId);</span>
<span class="nc" id="L371">            final Object content = imapMessage.getContent();</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (content instanceof Multipart) {</span>
<span class="nc" id="L373">                final BodyPart bp = extractBodypart((Multipart)content, id, isContentId);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                if (bp != null) {</span>
<span class="nc" id="L375">                    response.setContentType(bp.getContentType());</span>
<span class="nc" id="L376">                    bp.getDataHandler().writeTo(response.getOutputStream());</span>
<span class="nc" id="L377">                    response.getOutputStream().flush();</span>
                } else {
<span class="nc" id="L379">                    throw new NotFoundException(&quot;Attachment not found&quot;);</span>
                }
            }
<span class="nc" id="L382">        } catch (MessagingException | IOException ex) {</span>
<span class="nc" id="L383">            log.error(&quot;Error loading messages for folder: &quot; + folderId.toString(), ex);</span>
<span class="nc" id="L384">            throw  new IsotopeException(ex.getMessage());</span>
<span class="nc" id="L385">        }</span>

<span class="nc" id="L387">    }</span>

    /**
     * Moves the provided messages from the specified folderId to the specified destination folderId.
     *
     * To maximize compatibility with IMAP servers, move is performed using a regular copy and delete in the originating
     * folder, and a retrieval of messages in the target folder.
     *
     * @param fromFolderId name of the originating folder
     * @param toFolderId name of the target folder
     * @param uids list of uids to move
     * @return list of new messages in the target folder since the move operation started (may include additional messages)
     */
    public List&lt;MessageWithFolder&gt; moveMessages(URLName fromFolderId, URLName toFolderId, List&lt;Long&gt; uids) {
        try {
<span class="nc" id="L402">            final IMAPFolder fromFolder = getFolder(fromFolderId);</span>
<span class="nc" id="L403">            fromFolder.open(READ_WRITE);</span>
<span class="nc" id="L404">            final IMAPFolder toFolder = getFolder(toFolderId);</span>
<span class="nc" id="L405">            toFolder.open(READ_ONLY);</span>
<span class="nc" id="L406">            long toFolderNextUID = toFolder.getUIDNext();</span>
<span class="nc" id="L407">            toFolder.close(false);</span>

            // Maximize IMAP compatibility, perform COPY and DELETE
<span class="nc" id="L410">            final javax.mail.Message[] messagesToMove = Stream.of(getMessagesByUID(fromFolder, uids))</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                    .filter(m -&gt; !m.isExpunged())</span>
<span class="nc" id="L412">                    .toArray(javax.mail.Message[]::new);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            if (messagesToMove.length &gt; 0) {</span>
<span class="nc" id="L414">                fromFolder.copyMessages(messagesToMove, toFolder);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                for (javax.mail.Message m : messagesToMove) {</span>
<span class="nc" id="L416">                    m.setFlag(Flags.Flag.DELETED, true);</span>
                }
<span class="nc" id="L418">                fromFolder.expunge(messagesToMove);</span>
            }

            // Retrieve new messages in target folder
<span class="nc" id="L422">            toFolder.open(READ_ONLY);</span>
            // copy operation may not have finished, wait a little
            javax.mail.Message[] newMessages;
<span class="nc" id="L425">            int retries = 5;</span>
<span class="nc" id="L426">            final long sleepTimeMillis = 100L;</span>
<span class="nc bnc" id="L427" title="All 4 branches missed.">            while((newMessages = toFolder.getMessagesByUID(toFolderNextUID, UIDFolder.LASTUID)).length == 0</span>
                    &amp;&amp; retries-- &gt; 0) {
<span class="nc" id="L429">                Thread.sleep(sleepTimeMillis);</span>
            }
<span class="nc" id="L431">            envelopeFetch(toFolder, newMessages);</span>
<span class="nc" id="L432">            final List&lt;MessageWithFolder&gt; ret = Stream.of(newMessages)</span>
<span class="nc" id="L433">                    .map(m -&gt; MessageWithFolder.from(toFolder, true, (IMAPMessage)m))</span>
<span class="nc" id="L434">                    .collect(Collectors.toList());</span>
<span class="nc" id="L435">            fromFolder.close(false);</span>
<span class="nc" id="L436">            toFolder.close(false);</span>
<span class="nc" id="L437">            return ret;</span>
<span class="nc" id="L438">        } catch(InterruptedException ex) {</span>
<span class="nc" id="L439">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L440">            log.error(&quot;Error moving messages when waiting for COPY to complete&quot;, ex);</span>
<span class="nc" id="L441">            throw new IsotopeException(ex.getMessage(), ex);</span>

<span class="nc" id="L443">        } catch (MessagingException ex) {</span>
<span class="nc" id="L444">            log.error(&quot;Error moving messages&quot;, ex);</span>
<span class="nc" id="L445">            log.debug(&quot;Error moving messages from folder {} to folder {}&quot;, fromFolderId, toFolderId);</span>
<span class="nc" id="L446">            throw new IsotopeException(ex.getMessage(), ex);</span>
        }
    }

    /**
     * Sets the seen Flag ({@link javax.mail.Flags.Flag#SEEN}) to the provided boolean value for the specified
     * messages uids
     *
     * @param folderId
     * @param seen
     * @param uids
     */
    public void setMessagesSeen(URLName folderId, boolean seen, long... uids) {
<span class="fc" id="L459">        setMessagesFlag(folderId, Flags.Flag.SEEN, seen, uids);</span>
<span class="fc" id="L460">    }</span>

    public void setMessagesFlagged(URLName folderId, boolean flagged, long... uids) {
<span class="fc" id="L463">       setMessagesFlag(folderId, Flags.Flag.FLAGGED, flagged, uids);</span>
<span class="fc" id="L464">    }</span>

    /**
     * Flag deleted and expunge all messages from the provided folderId (Clear/Empty folder)
     *
     * @param folderId of the folder from which to delete all messages
     * @return updated folder after deleting all messages
     */
    public Folder deleteAllFolderMessages(@NonNull URLName folderId) {
        try {
<span class="fc" id="L474">            final IMAPFolder folder = getFolder(folderId);</span>
<span class="fc" id="L475">            folder.open(READ_WRITE);</span>
<span class="fc" id="L476">            folder.setFlags(folder.getMessages(), new Flags(Flags.Flag.DELETED), true);</span>
<span class="fc" id="L477">            folder.expunge();</span>
<span class="fc" id="L478">            return Folder.from(folder, true);</span>
<span class="nc" id="L479">        } catch (MessagingException ex) {</span>
<span class="nc" id="L480">            throw new IsotopeException(ex.getMessage(), ex);</span>
        }
    }

    public Folder deleteMessages(@NonNull URLName folderId, @NonNull List&lt;Long&gt; uids) {
        try {
<span class="fc" id="L486">            final IMAPFolder folder = getFolder(folderId);</span>
<span class="fc" id="L487">            folder.open(READ_WRITE);</span>
<span class="fc" id="L488">            final javax.mail.Message[] messages = getMessagesByUID(folder, uids);</span>
<span class="fc" id="L489">            folder.setFlags(messages, new Flags(Flags.Flag.DELETED), true);</span>
<span class="fc" id="L490">            folder.expunge(messages);</span>
<span class="fc" id="L491">            return Folder.from(folder, true);</span>
<span class="nc" id="L492">        } catch (MessagingException ex) {</span>
<span class="nc" id="L493">            throw new IsotopeException(ex.getMessage(), ex);</span>
        }
    }

    @PreDestroy
    public void destroy() {
<span class="nc" id="L499">        log.debug(&quot;ImapService destroyed&quot;);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">        if(imapStore != null) {</span>
            try {
<span class="nc" id="L502">                imapStore.close();</span>
                
                // log.info(&quot;++++++++++++++++++&quot;);
                // log.info(&quot;ImapService closed&quot;);
                // log.info(&quot;++++++++++++++++++&quot;);
                
<span class="nc" id="L508">            } catch (MessagingException ex) {</span>
<span class="nc" id="L509">                log.error(&quot;Error closing IMAP Store&quot;, ex);</span>
<span class="nc" id="L510">            }</span>
        }
<span class="nc" id="L512">    }</span>

    private IMAPStore getImapStore() throws MessagingException {
<span class="fc" id="L515">        return getImapStore((Credentials)SecurityContextHolder.getContext().getAuthentication());</span>
    }

    IMAPStore getImapStore(Credentials credentials) throws MessagingException {
<span class="fc bfc" id="L519" title="All 2 branches covered.">        if (imapStore == null) {</span>
<span class="fc" id="L520">            final Session session = Session.getInstance(initMailProperties(credentials, mailSSLSocketFactory), null);</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">            imapStore = (IMAPStore) session.getStore(credentials.getImapSsl() ? IMAPS_PROTOCOL : IMAP_PROTOCOL);</span>
<span class="fc" id="L522">            imapStore.connect(</span>
<span class="fc" id="L523">                    credentials.getServerHost(),</span>
<span class="fc" id="L524">                    credentials.getServerPort(),</span>
<span class="fc" id="L525">                    credentials.getUser(),</span>
<span class="fc" id="L526">                    credentials.getPassword());</span>
<span class="fc" id="L527">            log.debug(&quot;Opened new ImapStore session&quot;);</span>
            
            // log.info(&quot;Opened new ImapStore session from imapService&quot;);
            // log.info(&quot;---------------------------------------------&quot;);
            // log.info(&quot;credentials.getServerHost() --&gt; &quot; + credentials.getServerHost());
            // log.info(&quot;credentials.getServerPort() --&gt; &quot; + credentials.getServerPort());
            // log.info(&quot;credentials.getUser() --&gt; &quot; + credentials.getUser());
            // log.info(&quot;credentials.getPassword() --&gt; &quot; + credentials.getPassword());
            // log.info(&quot;---------------------------------------------&quot;);
            
        }
<span class="fc" id="L538">        return imapStore;</span>
    }

    List&lt;Message&gt; getMessages(
            @NonNull IMAPFolder folder, @Nullable Integer start, @Nullable Integer end, boolean fetchModseq)
            throws MessagingException {

<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (!folder.isOpen()) {</span>
<span class="nc" id="L546">            folder.open(READ_ONLY);</span>
        }
        final javax.mail.Message[] messages;
<span class="nc bnc" id="L549" title="All 4 branches missed.">        if (start != null &amp;&amp; end != null) {</span>
            // start / end message counts may no longer match, recalculate index if necessary
<span class="nc bnc" id="L551" title="All 2 branches missed.">            if (end &gt; folder.getMessageCount()) {</span>
<span class="nc" id="L552">                start = folder.getMessageCount() - (end - start);</span>
<span class="nc" id="L553">                end = folder.getMessageCount();</span>
            }
<span class="nc bnc" id="L555" title="All 2 branches missed.">            messages = folder.getMessages(start &lt; 1 ? 1 : start, end);</span>
        } else {
<span class="nc" id="L557">            messages = folder.getMessages();</span>
        }
<span class="nc" id="L559">        envelopeFetch(folder, messages);</span>
        final Long highestModseq;
<span class="nc bnc" id="L561" title="All 4 branches missed.">        if (fetchModseq &amp;&amp; messages.length &gt; 0) {</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">            highestModseq = folder.getHighestModSeq() == -1L ?</span>
<span class="nc" id="L563">                    ((IMAPMessage) messages[messages.length - 1]).getModSeq() : folder.getHighestModSeq();</span>
        } else {
<span class="nc" id="L565">            highestModseq = null;</span>
        }
<span class="nc" id="L567">        return Stream.of(messages)</span>
<span class="nc" id="L568">                .map(m -&gt; Message.from(folder, (IMAPMessage)m))</span>
<span class="nc" id="L569">                .peek(m -&gt; m.setModseq(highestModseq))</span>
<span class="nc" id="L570">                .sorted(Comparator.comparingLong(Message::getUid).reversed())</span>
<span class="nc" id="L571">                .collect(Collectors.toList());</span>
    }

    private IMAPFolder getFolder(URLName folderId) throws MessagingException {
<span class="fc" id="L575">        final IMAPFolder folder = (IMAPFolder)getImapStore().getFolder(getFileWithRef(folderId));</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (!folder.exists()) {</span>
<span class="fc" id="L577">            throw new NotFoundException(String.format(&quot;Folder %s not found&quot;, folderId.toString()));</span>
        }
<span class="fc" id="L579">        return folder;</span>
    }

    private void setMessagesFlag(URLName folderId, Flags.Flag flag, boolean flagValue, long... uids) {
        try {
<span class="fc" id="L584">            final IMAPFolder folder = getFolder(folderId);</span>
<span class="fc" id="L585">            folder.open(READ_WRITE);</span>
<span class="fc" id="L586">            final javax.mail.Message[] messages = getMessagesByUID(folder, uids);</span>
<span class="fc" id="L587">            folder.setFlags(messages, new Flags(flag), flagValue);</span>
<span class="fc" id="L588">            folder.close(false);</span>
<span class="nc" id="L589">        } catch (MessagingException ex) {</span>
<span class="nc" id="L590">            throw new IsotopeException(ex.getMessage(), ex);</span>
<span class="fc" id="L591">        }</span>
<span class="fc" id="L592">    }</span>

    /**
     * Returns a list of  {@link Attachment}s and replaces embedded images in {@link Message#content} if they are
     * small in order to avoid future calls to the API which may result more expensive.
     *
     * @param finalMessage
     * @param mp
     * @param attachments
     * @return
     * @throws MessagingException
     * @throws IOException
     */
    private List&lt;Attachment&gt; extractAttachments(
            @NonNull Message finalMessage, @NonNull Multipart mp, @Nullable List&lt;Attachment&gt; attachments)
            throws MessagingException, IOException {

<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (attachments == null){</span>
<span class="nc" id="L610">            attachments = new ArrayList&lt;&gt;();</span>
        }
<span class="nc bnc" id="L612" title="All 2 branches missed.">        for (int it = 0; it &lt; mp.getCount(); it++) {</span>
<span class="nc" id="L613">            final BodyPart bp = mp.getBodyPart(it);</span>
            // Multipart message with embedded parts
<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (bp.getContentType().toLowerCase().startsWith(MULTIPART_MIME_TYPE)) {</span>
<span class="nc" id="L616">                extractAttachments(finalMessage, (Multipart) bp.getContent(), attachments);</span>
            }
            // Image attachments
<span class="nc bnc" id="L619" title="All 4 branches missed.">            else if (bp.getContentType().toLowerCase().startsWith(&quot;image/&quot;)</span>
                    &amp;&amp; bp instanceof MimeBodyPart
<span class="nc bnc" id="L621" title="All 2 branches missed.">                    &amp;&amp; ((MimeBodyPart) bp).getContentID() != null) {</span>
                // If image is &quot;not too big&quot; embed as base64 data uri - successive IMAP connections will be more expensive
<span class="nc bnc" id="L623" title="All 2 branches missed.">                if (bp.getSize() &lt;= isotopeApiConfiguration.getEmbeddedImageSizeThreshold()) {</span>
<span class="nc" id="L624">                    finalMessage.setContent(replaceEmbeddedImage(finalMessage.getContent(), (MimeBodyPart)bp));</span>
                } else {
<span class="nc" id="L626">                    attachments.add(new Attachment(</span>
<span class="nc" id="L627">                            ((MimeBodyPart) bp).getContentID(), bp.getFileName(), bp.getContentType(), bp.getSize()));</span>
                }
            }
            // Embedded messages
<span class="nc bnc" id="L631" title="All 2 branches missed.">            else if (bp.getContentType().toLowerCase().startsWith(&quot;message/&quot;)) {</span>
<span class="nc" id="L632">                final Object nestedMessage = bp.getContent();</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">                if (nestedMessage instanceof MimeMessage) {</span>
<span class="nc" id="L634">                    attachments.add(new Attachment(null, ((MimeMessage)nestedMessage).getSubject(),</span>
<span class="nc" id="L635">                            bp.getContentType(), ((MimeMessage)nestedMessage).getSize()));</span>
                }
<span class="nc" id="L637">            }</span>
            // Regular files
<span class="nc bnc" id="L639" title="All 4 branches missed.">            else if (bp.getDisposition() != null &amp;&amp; bp.getDisposition().equalsIgnoreCase(Part.ATTACHMENT)) {</span>
<span class="nc" id="L640">                attachments.add(new Attachment(</span>
<span class="nc" id="L641">                        null, MimeUtility.decodeText(bp.getFileName()), bp.getContentType(), bp.getSize()));</span>
            }
        }
<span class="nc" id="L644">        return attachments;</span>
    }

    private void readContentIntoMessage(URLName folderId, @NonNull IMAPMessage imapMessage, @NonNull Message message)
            throws MessagingException, IOException {

<span class="nc" id="L650">        final Object content = imapMessage.getContent();</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">        if (content instanceof Multipart) {</span>
<span class="nc" id="L652">            message.setContent(extractContent((Multipart) content));</span>
<span class="nc" id="L653">            message.setAttachments(addLinks(Folder.toBase64Id(folderId), message,</span>
<span class="nc" id="L654">                    extractAttachments(message, (Multipart) content, null)));</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">        } else if (content instanceof MimeMessage</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                &amp;&amp; ((MimeMessage) content).getContentType().toLowerCase().contains(&quot;html&quot;)) {</span>
<span class="nc" id="L657">            message.setContent(content.toString());</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">        } else if (imapMessage.getContentType().indexOf(MediaType.TEXT_HTML_VALUE) == 0){</span>
<span class="nc" id="L659">            message.setContent(content.toString());</span>
        } else {
            //Preserve formatting
<span class="nc" id="L662">            message.setContent(content.toString()</span>
<span class="nc" id="L663">                    .replace(&quot;\r\n&quot;, &quot;&lt;br /&gt;&quot; )</span>
<span class="nc" id="L664">                    .replaceAll(&quot;[\\r\\n]&quot;, &quot;&lt;br /&gt;&quot;));</span>
        }
<span class="nc" id="L666">    }</span>

    /**
     * Returns an array of {@link javax.mail.Message} with &lt;strong&gt;no&lt;/strong&gt; null entries from an array of uids for
     * the provided {@link IMAPFolder}
     *
     * @param folder for which to retrieve the null-checked array of Messages
     * @param uids to retrieve the messages from the folder
     * @return array of Messages with no null entries
     * @throws MessagingException
     */
    private static javax.mail.Message[] getMessagesByUID(IMAPFolder folder, long[] uids) throws MessagingException {
<span class="fc" id="L678">        return Stream.of(folder.getMessagesByUID(uids)).filter(Objects::nonNull).toArray(javax.mail.Message[]::new);</span>
    }

    private static javax.mail.Message[] getMessagesByUID(IMAPFolder folder, List&lt;Long&gt; uids) throws MessagingException {
<span class="fc" id="L682">        return getMessagesByUID(folder, uids.stream().mapToLong(Long::longValue).toArray());</span>
    }

    private static Properties initMailProperties(@NonNull Credentials credentials, MailSSLSocketFactory mailSSLSocketFactory) {
<span class="fc" id="L686">        final Properties ret = new Properties();</span>
<span class="fc" id="L687">        ret.put(&quot;mail.imap.ssl.enable&quot;, credentials.getImapSsl());</span>
<span class="fc" id="L688">        ret.put(&quot;mail.imap.connectiontimeout&quot;, DEFAULT_CONNECTION_TIMEOUT);</span>
<span class="fc" id="L689">        ret.put(&quot;mail.imap.connectionpooltimeout&quot;, DEFAULT_CONNECTION_TIMEOUT);</span>
<span class="fc" id="L690">        ret.put(&quot;mail.imap.ssl.socketFactory&quot;, mailSSLSocketFactory);</span>
<span class="fc" id="L691">        ret.put(&quot;mail.imap.starttls.enable&quot;, true);</span>
<span class="fc" id="L692">        ret.put(&quot;mail.imap.starttls.required&quot;, false);</span>
<span class="fc" id="L693">        ret.put(&quot;mail.imaps.socketFactory&quot;, mailSSLSocketFactory);</span>
<span class="fc" id="L694">        ret.put(&quot;mail.imaps.socketFactory.fallback&quot;, false);</span>
<span class="fc" id="L695">        ret.put(&quot;mail.imaps.ssl.socketFactory&quot;, mailSSLSocketFactory);</span>
<span class="fc" id="L696">        return ret;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>